


{"package.json":"{\n  \"name\": \"content-editable\",\n  \"version\": \"0.0.0\",\n  \"description\": \"<description>\",\n  \"main\": \"./exports/index.js\",\n  \"module\": \"./exports/index.js\",\n  \"types\": \"./exports/index.d.ts\",\n  \"jsdelivr\": \"./bundles/all.js\",\n  \"exports\": {\n    \".\": \"./exports/index.js\",\n    \"./package.json\": \"./package.json\",\n    \"./exports/*.js\": \"./exports/*.js\",\n    \"./exports/*\": \"./exports/*\",\n    \"./types/*\": \"./types/*.d.ts\",\n    \"./cdn/exports/*.js\": \"./cdn/exports/*.js\",\n    \"./cdn/exports/*\": \"./cdn/exports/*\",\n    \"./bundles/*.js\": \"./bundles/*.js\",\n    \"./bundles/*\": \"./bundles/*\"\n  },\n  \"type\": \"module\",\n  \"files\": [\n    \"bundles\",\n    \"cdn\",\n    \"exports\",\n    \"internal\",\n    \"types\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"scripts\": {\n    \"start:docs\": \"cd docs && bin/bridgetown start\",\n    \"setup\": \"pnpm install && cd docs && pnpm install && bundle install\",\n    \"build:api\": \"typedoc --out ./docs/output/references/api/ ./exports/**/*.js\",\n    \"build:api-json\": \"typedoc --json ./typedoc-generation.json ./exports/**/*.js\",\n    \"build:cdn\": \"node esbuild.config.js\",\n    \"build:cem\": \"custom-elements-manifest analyze\",\n    \"build:docs\": \"pnpm run build && cd docs && pnpm run build\",\n    \"build\": \"npm run clean && tsc && npm run build:cem &&  npm run build:cdn\",\n    \"clean\": \"rimraf -g \\\"./{exports,internal}/**/*.d.ts\\\" -g \\\"./cdn\\\"\",\n    \"create:component\": \"plop component --plopfile scripts/plop/plopfile.js\",\n    \"rename-package\": \"plop rename-package --plopfile scripts/plop/plopfile.js\",\n    \"plop\": \"plop --plopfile scripts/plop/plopfile.js\",\n    \"watch:cem\": \"custom-elements-manifest analyze --watch\",\n    \"analyze\": \"custom-elements-manifest analyze --litelement\",\n    \"update-version\": \"node scripts/update-version.js\",\n    \"version\": \"npm run update-version && npm run build && git add internal/version.js\",\n    \"prepublish\": \"npm run update-version && npm run build\",\n    \"deploy:patch\": \"npm version patch && npm publish && git push --follow-tags\",\n    \"deploy:minor\": \"npm version minor && npm publish && git push --follow-tags\",\n    \"deploy:major\": \"npm version major && npm publish && git push --follow-tags\",\n    \"publish:beta\": \"npm publish --tag=beta && git push --follow-tags\",\n    \"lint\": \"prettier --check .\",\n    \"fix\": \"prettier --write .\",\n    \"verify\": \"npm run lint && npm run build && npm run test\",\n    \"test\": \"web-test-runner\",\n    \"test:watch\": \"web-test-runner --watch\"\n  },\n  \"keywords\": [\n\n  ],\n  \"license\": \"MIT\",\n  \"repository\": \"git@github.com:KonnorRogers/content-editable.git\",\n  \"bugs\": {\n    \"url\": \"https://github.com/KonnorRogers/content-editable/issues\"\n  },\n  \"homepage\": \"https://github.com/KonnorRogers/content-editable\",\n  \"author\": \"KonnorRogers <konnor5456@gmail.com>\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"devDependencies\": {\n    \"@custom-elements-manifest/analyzer\": \"0.10.2\",\n    \"@esm-bundle/chai\": \"4.3.4-fix.0\",\n    \"@open-wc/testing\": \"^4.0.0\",\n    \"@open-wc/testing-helpers\": \"^3.0.1\",\n    \"@types/node\": \"^20.14.8\",\n    \"@web/test-runner\": \"^0.18.2\",\n    \"@web/test-runner-commands\": \"^0.9.0\",\n    \"@web/test-runner-playwright\": \"^0.11.0\",\n    \"cem-plugin-expanded-types\": \"^1.3.1\",\n    \"esbuild\": \"^0.23.0\",\n    \"fdir\": \"^6.3.0\",\n    \"gh-pages\": \"^6.1.1\",\n    \"glob\": \"^10.4.1\",\n    \"globby\": \"^14.0.2\",\n    \"handlebars\": \"^4.7.8\",\n    \"playwright\": \"^1.44.1\",\n    \"plop\": \"^4.0.1\",\n    \"prettier\": \"^3.3.3\",\n    \"rimraf\": \"^5.0.7\",\n    \"typedoc\": \"^0.26.1\",\n    \"typescript\": \"~5.5.2\"\n  },\n  \"customElements\": \"custom-elements.json\",\n  \"dependencies\": {\n    \"konnors-lit-helpers\": \"^0.1.2\",\n    \"lit\": \"^3.2.0\",\n    \"web-component-define\": \"^2.0.11\"\n  }\n}","README.md":"# `content-editable`\n\n## Documentation\n\n<https://konnorrogers.github.io/content-editable>\n\n## Initial install\n\n```bash\nmkdir -p my-project-name\ncd my-project-name\ngit clone https://github.com/konnorrogers/npm-starter . --depth 1\nrm -rf .git\ngit init\npnpm install -D @web/test-runner @open-wc/testing-helpers @web/test-runner-playwright typescript rimraf @esm-bundle/chai playwright\npnpm exec playwright install --with-deps\n```\n\n## Renaming your package\n\n**THIS IS A DESTRUCTIVE ACTION THAT CANNOT BE UNDONE**\n\nTo rename your package, you can run the following command:\n\n```bash\nnpm run rename-package\n```\n\nWhich will prompt you for a new name.\n\n## Structure\n\n`exports/` is publicly available files\n`internal/` is...well...internal.\n\n`exports` and `internal` shouldn **NOT** write their own `.d.ts` that are co-located.\n\n`types/` is where you place your handwritten `.d.ts` files.\n","types/index.d.ts":"","exports/components/content-editor/content-editor-globals.d.ts":"import type ContentEditor from \"./content-editor.js\";\ndeclare global {\n    interface HTMLElementTagNameMap {\n        'content-editor': ContentEditor;\n    }\n    interface Selection {\n        getComposedRanges?(...shadowRoots: Node[]): StaticRange[];\n    }\n}\n/**\n * @see {https://w3c.github.io/input-events/}\n */\ninterface InputHandlers {\n    insertText: (evt: InputEvent, start: number, end: number) => void;\n    /** insert or replace existing content by means of a spell checker, auto-correct, writing suggestions or similar  */\n    insertReplacementText: (evt: InputEvent, start: number, end: number) => void;\n    insertLineBreak: (evt: InputEvent, start: number, end: number) => void;\n    insertParagraph: (evt: InputEvent, start: number, end: number) => void;\n    insertFromYank: (evt: InputEvent, start: number, end: number) => void;\n    insertFromDrop: (evt: InputEvent, start: number, end: number) => void;\n    insertFromPaste: (evt: InputEvent, start: number, end: number) => void;\n    /** transpose the last two grapheme cluster. that were entered  */\n    insertTranspose: (evt: InputEvent, start: number, end: number) => void;\n    /**  \treplace the current composition string  */\n    insertCompositionText: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete a word directly before the caret position  */\n    deleteWordBackward: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete a word directly after the caret position  */\n    deleteWordForward: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete from the caret to the nearest visual line break before the caret position  */\n    deleteSoftLineBackward: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete from the caret to the nearest visual line break after the caret position  */\n    deleteSoftLineForward: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete from the nearest visual line break before the caret position to the nearest visual line break after the caret position  */\n    deleteEntireSoftLine: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete from the caret to the nearest beginning of a block element or br element before the caret position  */\n    deleteHardLineBackward: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete from the caret to the nearest end of a block element or br element after the caret position  */\n    deleteHardLineForward: (evt: InputEvent, start: number, end: number) => void;\n    deleteByCut: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete the selection without specifying the direction of the deletion and this intention is not covered by another inputType  */\n    deleteContent: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete the content directly before the caret position and this intention is not covered by another inputType or delete the selection with the selection collapsing to its start after the deletion  */\n    deleteContentBackward: (evt: InputEvent, start: number, end: number) => void;\n    /**  delete the content directly after the caret position and this intention is not covered by another inputType or delete the selection with the selection collapsing to its end after the deletion  */\n    deleteContentForward: (evt: InputEvent, start: number, end: number) => void;\n    /**  undo the last editing action  */\n    historyUndo: (evt: InputEvent, start: number, end: number) => void;\n    /**  to redo the last undone editing action  */\n    historyRedo: (evt: InputEvent, start: number, end: number) => void;\n}\ninterface RichTextHandlers {\n    insertOrderedList: (evt: InputEvent, start: number, end: number) => void;\n    insertUnorderedList: (evt: InputEvent, start: number, end: number) => void;\n    insertHorizontalRule: (evt: InputEvent, start: number, end: number) => void;\n    insertFromPasteAsQuotation: (evt: InputEvent, start: number, end: number) => void;\n    /** remove content from the DOM by means of drag */\n    deleteByDrag: (evt: InputEvent, start: number, end: number) => void;\n    insertLink: (evt: InputEvent, start: number, end: number) => void;\n    formatBold: (evt: InputEvent, start: number, end: number) => void;\n    formatItalic: (evt: InputEvent, start: number, end: number) => void;\n    formatUnderline: (evt: InputEvent, start: number, end: number) => void;\n    formatStrikeThrough: (evt: InputEvent, start: number, end: number) => void;\n    formatSuperscript: (evt: InputEvent, start: number, end: number) => void;\n    formatSubscript: (evt: InputEvent, start: number, end: number) => void;\n    formatJustifyFull: (evt: InputEvent, start: number, end: number) => void;\n    formatJustifyCenter: (evt: InputEvent, start: number, end: number) => void;\n    formatJustifyRight: (evt: InputEvent, start: number, end: number) => void;\n    formatJustifyLeft: (evt: InputEvent, start: number, end: number) => void;\n    formatIndent: (evt: InputEvent, start: number, end: number) => void;\n    formatOutdent: (evt: InputEvent, start: number, end: number) => void;\n    formatRemove: (evt: InputEvent, start: number, end: number) => void;\n    formatSetBlockTextDirection: (evt: InputEvent, start: number, end: number) => void;\n    formatSetInlineTextDirection: (evt: InputEvent, start: number, end: number) => void;\n    formatBackColor: (evt: InputEvent, start: number, end: number) => void;\n    formatFontColor: (evt: InputEvent, start: number, end: number) => void;\n    formatFontName: (evt: InputEvent, start: number, end: number) => void;\n}\nexport type { InputHandlers, RichTextHandlers };\n","exports/components/content-editor/content-editor-globals.ts":"import type ContentEditor from \"./content-editor.js\"\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'content-editor': ContentEditor\n  }\n\n  interface Selection {\n    getComposedRanges?(...shadowRoots: Node[]): StaticRange[]\n  }\n}\n\n/**\n * @see {https://w3c.github.io/input-events/}\n */\ninterface InputHandlers {\n  insertText: (evt: InputEvent, start: number, end: number) => void\n  /** insert or replace existing content by means of a spell checker, auto-correct, writing suggestions or similar  */\n  insertReplacementText: (evt: InputEvent, start: number, end: number) => void\n  insertLineBreak: (evt: InputEvent, start: number, end: number) => void\n  insertParagraph: (evt: InputEvent, start: number, end: number) => void\n  insertFromYank: (evt: InputEvent, start: number, end: number) => void\n  insertFromDrop: (evt: InputEvent, start: number, end: number) => void\n  insertFromPaste: (evt: InputEvent, start: number, end: number) => void\n\n  /** transpose the last two grapheme cluster. that were entered  */\n  insertTranspose: (evt: InputEvent, start: number, end: number) => void\n\n  /**  \treplace the current composition string  */\n  insertCompositionText: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete a word directly before the caret position  */\n  deleteWordBackward: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete a word directly after the caret position  */\n  deleteWordForward: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete from the caret to the nearest visual line break before the caret position  */\n  deleteSoftLineBackward: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete from the caret to the nearest visual line break after the caret position  */\n  deleteSoftLineForward: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete from the nearest visual line break before the caret position to the nearest visual line break after the caret position  */\n  deleteEntireSoftLine: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete from the caret to the nearest beginning of a block element or br element before the caret position  */\n  deleteHardLineBackward: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete from the caret to the nearest end of a block element or br element after the caret position  */\n  deleteHardLineForward: (evt: InputEvent, start: number, end: number) => void\n\n  deleteByCut: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete the selection without specifying the direction of the deletion and this intention is not covered by another inputType  */\n  deleteContent: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete the content directly before the caret position and this intention is not covered by another inputType or delete the selection with the selection collapsing to its start after the deletion  */\n  deleteContentBackward: (evt: InputEvent, start: number, end: number) => void\n\n  /**  delete the content directly after the caret position and this intention is not covered by another inputType or delete the selection with the selection collapsing to its end after the deletion  */\n  deleteContentForward: (evt: InputEvent, start: number, end: number) => void\n\n  /**  undo the last editing action  */\n  historyUndo: (evt: InputEvent, start: number, end: number) => void\n\n  /**  to redo the last undone editing action  */\n  historyRedo: (evt: InputEvent, start: number, end: number) => void\n\n\n}\n\n// these are really for RTEs, not for regular plaintext handlers.\ninterface RichTextHandlers {\n  insertOrderedList: (evt: InputEvent, start: number, end: number) => void\n  insertUnorderedList: (evt: InputEvent, start: number, end: number) => void\n  insertHorizontalRule: (evt: InputEvent, start: number, end: number) => void\n  insertFromPasteAsQuotation: (evt: InputEvent, start: number, end: number) => void\n\n  /** remove content from the DOM by means of drag */\n  deleteByDrag: (evt: InputEvent, start: number, end: number) => void\n\n  insertLink: (evt: InputEvent, start: number, end: number) => void\n  formatBold: (evt: InputEvent, start: number, end: number) => void\n  formatItalic: (evt: InputEvent, start: number, end: number) => void\n  formatUnderline: (evt: InputEvent, start: number, end: number) => void\n  formatStrikeThrough: (evt: InputEvent, start: number, end: number) => void\n  formatSuperscript: (evt: InputEvent, start: number, end: number) => void\n  formatSubscript: (evt: InputEvent, start: number, end: number) => void\n  formatJustifyFull: (evt: InputEvent, start: number, end: number) => void\n  formatJustifyCenter: (evt: InputEvent, start: number, end: number) => void\n  formatJustifyRight: (evt: InputEvent, start: number, end: number) => void\n  formatJustifyLeft: (evt: InputEvent, start: number, end: number) => void\n  formatIndent: (evt: InputEvent, start: number, end: number) => void\n  formatOutdent: (evt: InputEvent, start: number, end: number) => void\n  formatRemove: (evt: InputEvent, start: number, end: number) => void\n  formatSetBlockTextDirection: (evt: InputEvent, start: number, end: number) => void\n  formatSetInlineTextDirection: (evt: InputEvent, start: number, end: number) => void\n  formatBackColor: (evt: InputEvent, start: number, end: number) => void\n  formatFontColor: (evt: InputEvent, start: number, end: number) => void\n  formatFontName: (evt: InputEvent, start: number, end: number) => void\n}\n\n\nexport type {\n  InputHandlers,\n  RichTextHandlers\n}\n","exports/components/content-editor/content-editor-register.d.ts":"export default ContentEditable;\nexport * from \"./content-editor.js\";\nimport ContentEditable from './content-editor.js';\n","exports/components/content-editor/content-editor-register.js":"// @ts-check\nimport ContentEditable from './content-editor.js';\n\n// ContentEditable.define('content-editor');\n\nexport default ContentEditable;\nexport * from './content-editor.js';\nimport \"./content-editor.js\"\n\n/**\n * @type {import(\"./content-editor-globals.js\")}\n */\n","exports/components/content-editor/content-editor.d.ts":"export default class ContentEditorElement extends LitElement {\n    static formAssociated: boolean;\n    /**\n     * @override\n     */\n    static override styles: import(\"lit\").CSSResult[];\n    internals: ElementInternals;\n    eventPrefix: string;\n    contentEditor: ContentEditor | undefined;\n    /**\n     * @param {string | undefined | null} val\n     */\n    set value(val: string | null | undefined);\n    get value(): string | null | undefined;\n    /**\n     * @override\n     */\n    override render(): import(\"lit\").TemplateResult<1>;\n    /**\n     * @param {HTMLElement} contentEditableElement\n     */\n    contentEditableChanged(contentEditableElement: HTMLElement): void;\n    contentEditableElement: HTMLElement | undefined;\n    set required(t: boolean);\n    get required(): boolean;\n    get form(): HTMLFormElement | null;\n}\n/**\n * @typedef {Object} ContentEditorOptions\n * @property {string} content\n * @property {string} [eventPrefix]\n * @property {HTMLElement} contentEditableElement - The element with `contenteditable=\"true\"`\n */\nexport class ContentEditor {\n    /**\n     * @param {ContentEditorOptions} options\n     */\n    constructor({ contentEditableElement, content, eventPrefix, }: ContentEditorOptions);\n    eventPrefix: string;\n    document: ContentDocument;\n    inputHandler: InputHandler;\n    actionHandler: ActionHandler;\n    keybindings: {\n        \"Ctrl+Z\": string;\n        \"Ctrl+Shift+Z\": string;\n    };\n    destroy(): void;\n    /**\n     * @param {CESelectionChangeEvent} _evt\n     */\n    handleChange(_evt: CESelectionChangeEvent): void;\n    /**\n     * @param {Event} evt\n     */\n    handleEvent(evt: Event): void;\n    /**\n     * @param {InputEvent} evt\n     */\n    handleBeforeInput(evt: InputEvent): void;\n    /**\n     * @param {Event} evt\n     */\n    handleSelectionChange(evt: Event): void;\n    /**\n     * @param {KeyboardEvent} evt\n     */\n    handleKeydown(evt: KeyboardEvent): void;\n    /**\n     * @param {KeyboardEvent} evt\n     */\n    normalizeKeybinding(evt: KeyboardEvent): string;\n    get content(): string;\n    get contentEditableElement(): HTMLElement;\n    render(): void;\n}\nexport type ContentDocumentOptions = {\n    /**\n     * - initial string\n     */\n    content: string;\n    /**\n     * - The actual \"contenteditable\" element.\n     */\n    contentEditableElement: HTMLElement;\n    eventPrefix?: string | undefined;\n};\nexport type InputHandlers = import(\"./content-editor-globals.js\").InputHandlers;\nexport type ContentEditorOptions = {\n    content: string;\n    eventPrefix?: string | undefined;\n    /**\n     * - The element with `contenteditable=\"true\"`\n     */\n    contentEditableElement: HTMLElement;\n};\nimport { LitElement } from \"lit\";\n/**\n * @typedef {Object} ContentDocumentOptions\n * @property {string} content - initial string\n * @property {HTMLElement} contentEditableElement - The actual \"contenteditable\" element.\n * @property {string} [eventPrefix=\"content-editor\"]\n */\ndeclare class ContentDocument {\n    /**\n     * @param {ContentDocumentOptions} options\n     */\n    constructor(options: ContentDocumentOptions);\n    content: string;\n    contentEditableElement: HTMLElement;\n    eventPrefix: string;\n    selection: SelectionHelper<this>;\n    history: ContentDocumentHistory;\n    gutterStart: string;\n    gutterEnd: string;\n    lineStart: string;\n    lineEnd: string;\n    /**\n     * @param {number} start\n     * @param {number} end\n     */\n    select(start: number, end: number): void;\n    /**\n     * @param {string} text\n     */\n    insertText(text: string): void;\n    /**\n     * @param {string} text\n     * @param {number} start\n     * @param {number} end\n     */\n    replaceText(text: string, start: number, end: number): void;\n    /**\n     * @param {number} start\n     * @param {number} end\n     */\n    insertParagraph(start: number, end: number): void;\n    /**\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteText(start: number, end: number): void;\n    deleteCurrentLine(): void;\n    undo(): void;\n    redo(): void;\n    /**\n    * @param {string} str\n    */\n    escapeHTML(str: string): string;\n    render(): void;\n    get isEmpty(): boolean;\n    get currentSelection(): {\n        start: number;\n        end: number;\n        selection: string;\n    };\n    get currentLine(): {\n        start: number;\n        end: number;\n        content: string;\n        selectedContent: string;\n    };\n    /**\n     * @param {boolean} bool\n     * @param {string} startText\n     * @param {string} [endText=startText]\n     */\n    toggleSurround(bool: boolean, startText: string, endText?: string | undefined): void;\n    /**\n     * @param {string} startText\n     * @param {string} [endText=startText]\n     */\n    addSurround(startText: string, endText?: string | undefined): void;\n    /**\n     * @param {string} startText\n     * @param {string} [endText=startText]\n     */\n    deleteSurround(startText: string, endText?: string | undefined): void;\n    /**\n     * @param {string} text\n     */\n    insertAtStart(text: string): void;\n    /**\n     * @param {string | RegExp} strOrRegexp\n     */\n    deleteFromStart(strOrRegexp: string | RegExp): void;\n    addHistory(): void;\n    /**\n     * @param {string} text\n     * @param {{ start: number, end: number }} selection\n     */\n    updateEditor(text: string, selection: {\n        start: number;\n        end: number;\n    }): void;\n    get currentState(): {\n        content: string;\n        start: number;\n        end: number;\n    };\n}\n/** @typedef {import(\"./content-editor-globals.js\").InputHandlers} InputHandlers */\n/**\n * @implements {InputHandlers}\n */\ndeclare class InputHandler implements InputHandlers {\n    /**\n     * @param {ContentDocument} t\n     */\n    constructor(t: ContentDocument);\n    document: ContentDocument;\n    /**\n     * @param {InputEvent} evt\n     * @param {HTMLElement} container\n     */\n    handleInput(evt: InputEvent, container: HTMLElement): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertText(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertLineBreak(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} _start\n     * @param {number} _end\n     */\n    historyRedo(_evt: InputEvent, _start: number, _end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} _start\n     * @param {number} _end\n     */\n    historyUndo(_evt: InputEvent, _start: number, _end: number): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertCompositionText(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertParagraph(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromYank(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromDrop(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromPasteAsQuotation(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertTranspose(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertReplacementText(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromPaste(evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteContentBackward(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteByCut(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteWordBackward(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteWordForward(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteSoftLineBackward(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteSoftLineForward(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteEntireSoftLine(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteHardLineBackward(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteHardLineForward(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteContent(_evt: InputEvent, start: number, end: number): void;\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteContentForward(_evt: InputEvent, start: number, end: number): void;\n}\ndeclare class ActionHandler {\n    /**\n     * @param {ContentDocument} document\n     */\n    constructor(document: ContentDocument);\n    document: ContentDocument;\n    /**\n     * @template {Exclude<keyof this & InputEvent[\"inputType\"], \"handleAction\" | \"constructor\">} T\n     * @param {Omit<string, T> | T & {}} t\n     * @param {Event} e\n     */\n    handleAction<T extends Exclude<keyof this & InputEvent[\"inputType\"], \"handleAction\" | \"constructor\">>(t: Omit<string, T> | (T & {}), e: Event): void;\n    undo(): void;\n    redo(): void;\n}\ndeclare class CESelectionChangeEvent extends BaseEvent {\n    /**\n     * @param {string} eventName\n     * @param {EventInit & { detail: { start: number, end: number }}} options\n     */\n    constructor(eventName: string, options: EventInit & {\n        detail: {\n            start: number;\n            end: number;\n        };\n    });\n}\n/**\n * @template {ContentDocument} T\n */\ndeclare class SelectionHelper<T extends ContentDocument> {\n    /**\n     * @param {T} contentDocument\n     * @param {{eventPrefix?: string}} [options={}]\n     */\n    constructor(contentDocument: T, options?: {\n        eventPrefix?: string;\n    } | undefined);\n    document: T;\n    rangeHelper: RangeHelper;\n    selection: string;\n    eventPrefix: string;\n    current(): {\n        start: number;\n        end: number;\n        selection: string;\n    };\n    currentLine(): {\n        start: number;\n        end: number;\n        content: string;\n        selectedContent: string;\n    };\n    previousLine(): {\n        start: number;\n        end: number;\n        content: string;\n        selectedContent: string;\n    } & {\n        selectedContent: string;\n    };\n    nextLine(): {\n        start: number;\n        end: number;\n        content: string;\n        selectedContent: string;\n    } & {\n        selectedContent: string;\n    };\n    moveUp(): void;\n    moveDown(): void;\n    /**\n     * @param {number} offset\n     */\n    lineAt(offset: number): {\n        start: number;\n        end: number;\n        content: string;\n        selectedContent: string;\n    };\n    /**\n     * @param {Range | null | undefined} [range]\n     */\n    getCurrentLineNumber(range?: Range | null | undefined): number | null;\n    /**\n     * @param {number} lineNumber\n     */\n    setActiveLineNumber(lineNumber: number): void;\n    /**\n     * @param {Object} options\n     * @param {number} options.start\n     * @param {number} options.end\n     */\n    select({ start, end }: {\n        start: number;\n        end: number;\n    }): void;\n    documentRange: RangeHelper | undefined;\n    updateRange(): void;\n    currentLineNumber: number | undefined;\n    update: () => void;\n    get start(): number;\n    get end(): number;\n    get contentEditableElement(): HTMLElement;\n    get isEmpty(): boolean;\n    get isMultiline(): boolean;\n    /**\n     * This is useful if you ever build a markdown editor.\n     * this.hasQuery(\"h1\") -> checks if the selection has a \"h1\" element.\n     * @param {string} selector - a querySelector to be passed to `.closest()`\n     */\n    hasQuery(selector: string): boolean;\n}\ndeclare class ContentDocumentHistory {\n    static saveInterval: number;\n    constructor(t?: number);\n    maxSize: number;\n    /**\n     * @type {Array<ContentDocument[\"currentState\"]>}\n     */\n    undoStack: Array<ContentDocument[\"currentState\"]>;\n    /**\n     * @type {Array<ContentDocument[\"currentState\"]>}\n     */\n    redoStack: Array<ContentDocument[\"currentState\"]>;\n    /**\n     * @param {ContentDocument[\"currentState\"]} t\n     */\n    undo(t: ContentDocument[\"currentState\"]): {\n        content: string;\n        start: number;\n        end: number;\n    } | null;\n    /**\n     * @param {ContentDocument[\"currentState\"]} t\n     */\n    redo(t: ContentDocument[\"currentState\"]): {\n        content: string;\n        start: number;\n        end: number;\n    } | null;\n    /**\n     * @param {ContentDocument[\"currentState\"]} transaction\n     */\n    add: (transaction: ContentDocument[\"currentState\"]) => void;\n}\ndeclare class BaseEvent extends CustomEvent<any> {\n    /**\n     * @param {string} eventName\n     * @param {EventInit} [options]\n     */\n    constructor(eventName: string, options?: EventInit | undefined);\n}\ndeclare class RangeHelper {\n    /**\n     * @param {StaticRange | Range} range\n     * @param {Element} container\n     */\n    static fromDOMRange(range: StaticRange | Range, container: Element): RangeHelper;\n    /**\n     * @param {Element} container\n     * @param {number} start\n     * @param {number} end\n     */\n    constructor(container: Element, start: number, end: number);\n    start: number;\n    end: number;\n    container: Element;\n    toDOMRange(): Range;\n    /**\n     * @param {RangeHelper} selection\n     */\n    isEqual(selection: RangeHelper): boolean;\n}\nexport {};\n","exports/components/content-editor/content-editor.js":"import { html, LitElement } from \"lit\";\nimport { ref } from 'lit/directives/ref.js';\nimport {componentStyles} from './content-editor.styles.js'\nimport { baseStyles } from \"../../styles/base.styles.js\";\n\nconst zeroWidthWhitespace = \"â€‹\"\n// const zeroWidthWhitespace = \" \"\n\nclass BaseEvent extends CustomEvent {\n    /**\n     * @param {string} eventName\n     * @param {EventInit} [options]\n     */\n    constructor(eventName, options) {\n        if (!options) { options = {} }\n        if (options.bubbles == null) { options.bubbles = true }\n        if (options.cancelable == null) { options.cancelable = false }\n        if (options.composed == null) { options.composed = false }\n        super(eventName, options)\n    }\n}\n\nclass CESelectionChangeEvent extends BaseEvent {\n    /**\n     * @param {string} eventName\n     * @param {EventInit & { detail: { start: number, end: number }}} options\n     */\n    constructor(eventName, options) {\n        super(eventName, options)\n    }\n}\n\nclass CEChangeEvent extends BaseEvent {\n    /**\n     * @param {string} eventName\n     * @param {EventInit & { detail: { previousContent: string, newContent: string }}} options\n     */\n    constructor(eventName, options) {\n        super(eventName, options)\n    }\n}\n\nclass RangeHelper {\n    /**\n     * @param {StaticRange | Range} range\n     * @param {Element} container\n     */\n    static fromDOMRange(range, container) {\n        const {startOffset, startContainer, endOffset, endContainer} = range\n        const start = findOffset(container, startContainer, startOffset);\n\n        if (range.collapsed) {\n            return new RangeHelper(container,start,start);\n        }\n\n        const end = findOffset(container, endContainer, endOffset);\n        return new RangeHelper(container,start,end)\n    }\n\n    /**\n     * @param {Element} container\n     * @param {number} start\n     * @param {number} end\n     */\n    constructor(container, start, end) {\n        this.start = start || 0;\n        this.end = end || 0;\n        this.container = container\n    }\n    toDOMRange() {\n        const range = document.createRange();\n        const treewalker = document.createTreeWalker(this.container);\n\n        range.setStart(this.container, 1)\n        range.setEnd(this.container, this.container.childNodes.length / 2)\n        let offset = 0\n        let startFound = false\n        let endFound = false\n\n        while (treewalker.nextNode() && (!startFound || !endFound)) {\n            if (\n                treewalker.currentNode.nodeType !== Node.TEXT_NODE\n            ) { continue }\n\n            if (treewalker.currentNode?.parentElement?.closest(\"[part~='gutter']\")) {\n                continue\n            }\n\n            let textLength = treewalker.currentNode?.textContent?.length || 0;\n\n            if (!startFound && offset + textLength >= this.start) {\n                startFound = true\n\n                const start = this.start - offset\n\n                let node = treewalker.currentNode\n                range.setStart(node, start)\n            }\n\n            if (!endFound && offset + textLength >= this.end) {\n                endFound = true\n                const end = this.end - offset\n\n                let node = treewalker.currentNode\n                range.setEnd(node, end)\n            }\n\n            offset += textLength\n        }\n\n        return range\n    }\n\n    /**\n     * @param {RangeHelper} selection\n     */\n    isEqual(selection) {\n        return this.container === selection.container && this.start === selection.start && this.end === selection.end\n    }\n}\n\n/**\n * @param {Element | Node} container\n * @param {Element | Node} offsetContainer\n * @param {number} offset\n */\nfunction findOffset(container, offsetContainer, offset) {\n    if (offsetContainer.nodeType === Node.ELEMENT_NODE) {\n        const startNode = offsetContainer.childNodes[offset];\n        let finalOffset = 0;\n        const treewalker = document.createTreeWalker(container);\n        while (treewalker.nextNode()) {\n            if (treewalker.currentNode === startNode) { return finalOffset; }\n\n            // Keep walking until we get to a text node or new line.\n            if (treewalker.currentNode.nodeType === Node.TEXT_NODE) {\n                if (treewalker.currentNode?.parentElement?.closest(\"[part~='gutter']\")) {\n                    continue\n                }\n\n                let textLength = (treewalker.currentNode?.textContent?.length || 0)\n\n                finalOffset += textLength\n            }\n        }\n        return finalOffset\n    }\n\n    const treewalker = document.createTreeWalker(container);\n    while (treewalker.nextNode()) {\n        if (treewalker.currentNode === offsetContainer) {\n            return offset;\n        }\n\n        if (treewalker.currentNode.nodeType !== Node.TEXT_NODE) { continue }\n        if (treewalker.currentNode?.parentElement?.closest(\"[part~='gutter']\")) {\n            continue\n        }\n\n        let textLength = treewalker.currentNode?.textContent?.length || 0\n\n        offset += textLength\n    }\n    return offset\n}\n\n/**\n * @template {ContentDocument} T\n */\nclass SelectionHelper {\n    /**\n     * @param {T} contentDocument\n     * @param {{eventPrefix?: string}} [options={}]\n     */\n    constructor(contentDocument, options = {}) {\n        if (!options) { options = {} }\n\n        const { eventPrefix } = options\n\n        this.document = contentDocument\n        this.rangeHelper = new RangeHelper(/** @type {HTMLElement} */ (this.contentEditableElement),0,0)\n        this.selection = \"\"\n        this.eventPrefix = eventPrefix || \"content-editor-\"\n    }\n    current() {\n        return {\n            start: this.start,\n            end: this.end,\n            selection: this.selection\n        }\n    }\n    currentLine() {\n        return this.lineAt(this.end)\n    }\n\n    previousLine() {\n        const {content} = this.document\n        const offset = Math.max(content.lastIndexOf(\"\\n\", this.start - 1), 0);\n        return Object.assign(this.lineAt(offset), { selectedContent: \"\" })\n    }\n\n    nextLine () {\n        const {content} = this.document\n        const offset = Math.max(content.lastIndexOf(\"\\n\", this.end) + 1, 0);\n        return Object.assign(this.lineAt(offset), { selectedContent: \"\" })\n    }\n\n    moveUp () {\n        if ((this.getCurrentLineNumber() || 1) <= 1) {\n            this.select({ start: 0, end: 0 })\n            return\n        }\n\n        const currentLine = this.currentLine()\n        const currentLineOffset = currentLine.selectedContent.length + 1\n        const prevLineOffset = (this.document.selection.start - currentLineOffset) // Brings us to beginning of line\n        const previousLine = this.lineAt(Math.max(prevLineOffset, 0))\n        console.log(previousLine.content)\n\n        let inc = 1\n\n        if (previousLine.content.startsWith(zeroWidthWhitespace)) {\n            inc = 2\n        }\n\n        const offset = prevLineOffset - previousLine.content.length + inc// + Math.min(currentLineOffset, previousLine.content.length)\n        this.select({ start: offset, end: offset })\n    }\n\n    moveDown () {\n        const currentLine = this.currentLine()\n        const currentLineNumber = (this.getCurrentLineNumber() || 1)\n        if (currentLineNumber >= this.document.content.split(\"\\n\").length) {\n            this.select({ start: currentLine.end, end: currentLine.end})\n            return\n        }\n\n        let currentLineOffset = Math.max(currentLine.selectedContent.length - 1, 0)\n\n        let nextLineOffset = (this.document.selection.start - currentLineOffset + Math.max(currentLine.content.length, 2)) // Brings us to beginning of next line\n\n        const nextLine = this.lineAt(Math.min(nextLineOffset, this.document.content.length))\n\n        console.log({\n            currentLineOffset,\n            nextLineLength: nextLine.content.length\n        })\n\n        const offset = nextLineOffset // + Math.max(Math.min(nextLine.content.length, currentLineOffset), 0)\n        this.select({ start: offset, end: offset })\n    }\n\n    /**\n     * @param {number} offset\n     */\n    lineAt(offset) {\n        const {content} = this.document\n        const start = Math.max(content.lastIndexOf(\"\\n\", offset - 1) + 1, 0)\n        const startOffset = content.indexOf(\"\\n\", offset)\n        const end = -1 === startOffset ? content.length : startOffset + 1;\n        return {\n            start,\n            end,\n            content: content.slice(start, end),\n            selectedContent: content.slice(start, offset),\n        }\n    }\n\n    /**\n     * @param {Range | null | undefined} [range]\n     */\n    getCurrentLineNumber (range) {\n        if (!range) {\n            const rangeHelper = new RangeHelper(this.contentEditableElement,this.start,this.end);\n            range = rangeHelper.toDOMRange();\n        }\n\n        if (range.collapsed) {\n            const lineEl = range.endContainer?.parentElement?.closest(\"[part~='line']\")\n            const children = this.contentEditableElement.children\n            const index = Array.prototype.indexOf.call(children, lineEl)\n            let lineNumber = null\n            if (index >= 0) {\n                lineNumber = (Math.max(0, (index - 1)) / 2) + 1\n                return lineNumber\n            }\n            return null\n        }\n\n        return null\n    }\n\n    /**\n     * @param {number} lineNumber\n     */\n    setActiveLineNumber (lineNumber) {\n      Array.prototype.forEach.call(this.contentEditableElement.children, (el) => el.part.remove(\"active-line\"))\n      const child = this.contentEditableElement.children[((lineNumber - 1) * 2) + 1]\n      child.part.add(\"active-line\")\n    }\n\n    /**\n     * @param {Object} options\n     * @param {number} options.start\n     * @param {number} options.end\n     */\n    select({start, end}) {\n        if (!this.contentEditableElement) { return }\n\n        this.documentRange = new RangeHelper(this.contentEditableElement,start,end);\n\n        let range = this.documentRange.toDOMRange();\n\n        if (!range) {\n            console.error(\"Failed to create range\", {\n                start,\n                end\n            })\n            return\n        }\n\n        /**\n         * TODO: We should cache these checks by moving them to a ResizeObserver.\n         */\n        const caretRect = range.getBoundingClientRect();\n        const containerRect = this.contentEditableElement.getBoundingClientRect();\n\n        // Calculate if the caret is out of view\n        // TODO: Calculate right / left scrolling as well.\n        if (caretRect.bottom > containerRect.bottom) {\n            // Scroll down\n            this.contentEditableElement.scrollTop += caretRect.bottom - containerRect.bottom + (caretRect.height / 2);\n        } else if (caretRect.bottom + containerRect.height < containerRect.bottom) {\n            // Scroll up normal. We're at the \"top\" of the contenteditable.\n            this.contentEditableElement.scrollTop -= containerRect.top - caretRect.top;\n        } else if (caretRect.top < containerRect.top) {\n            // Scroll up + 1 extra line.\n            this.contentEditableElement.scrollTop -= containerRect.top - caretRect.top - (caretRect.height);\n        }\n\n        const selection = document.getSelection();\n\n        if (!selection) { return }\n\n        if (typeof selection.setBaseAndExtent === \"function\") {\n            selection.setBaseAndExtent(\n                range.startContainer,\n                range.startOffset,\n                range.endContainer || range.startContainer,\n                range.endOffset || range.startOffset\n            )\n        } else {\n            selection.removeAllRanges()\n            selection.addRange(range)\n        }\n\n        this.update()\n    }\n\n    updateRange () {\n        let range = null\n\n        const rootNode = this.contentEditableElement.getRootNode()\n        // @ts-expect-error\n        const selection = rootNode.getSelection?.() || document.getSelection()\n\n        if (!selection) { return }\n        if (!this.contentEditableElement)  { return }\n\n        let hasNode = true\n\n        // Special handling of shadow dom in safari.\n        if (typeof selection.getComposedRanges === \"function\" && rootNode instanceof ShadowRoot) {\n            const staticRange = selection.getComposedRanges(rootNode)[0]\n            if (!staticRange) { return }\n\n            /**\n             * @type {Node | Element | null | undefined}\n             */\n            let parent = staticRange.startContainer\n            while ((parent = parent?.parentElement)) {\n                if (parent === this.contentEditableElement) {\n                    hasNode = true\n                    break;\n                }\n            }\n            range = staticRange\n        } else {\n            range = selection.getRangeAt(0)\n            hasNode = range.intersectsNode(this.contentEditableElement)\n        }\n\n        if (!range) { return }\n\n        if (hasNode) {\n            this.rangeHelper = RangeHelper.fromDOMRange(range, this.contentEditableElement)\n            this.selection = this.document.content.slice(this.start, this.end)\n\n            const lineNumber = this.getCurrentLineNumber(this.rangeHelper.toDOMRange())\n\n            if (lineNumber != null) {\n                this.setActiveLineNumber(lineNumber)\n                this.currentLineNumber = lineNumber\n            }\n        }\n    }\n    update = () => {\n        const rangeHelper = this.rangeHelper;\n\n        this.updateRange()\n\n        if (this.rangeHelper.isEqual(rangeHelper)) { return }\n\n        const selectionChangeEvent = new CESelectionChangeEvent(`${this.eventPrefix}selectionchange`, {\n            detail: {\n                start: this.start,\n                end: this.end\n            }\n        })\n\n        this.contentEditableElement.dispatchEvent(selectionChangeEvent)\n    }\n\n    get start() {\n        return this.rangeHelper.start\n    }\n    get end() {\n        return this.rangeHelper.end\n    }\n    get contentEditableElement() {\n        return this.document.contentEditableElement\n    }\n    get isEmpty() {\n        return this.start === this.end\n    }\n    get isMultiline() {\n        return this.current().selection.includes(\"\\n\")\n    }\n\n    /**\n     * This is useful if you ever build a markdown editor.\n     * this.hasQuery(\"h1\") -> checks if the selection has a \"h1\" element.\n     * @param {string} selector - a querySelector to be passed to `.closest()`\n     */\n    hasQuery(selector) {\n        /**\n         * @type {HTMLElement | Node | undefined | null}\n         */\n        let e = window.getSelection()?.getRangeAt(0)?.endContainer;\n        if (!e) { return false }\n\n        if (e.nodeType === Node.TEXT_NODE) {\n            const parentElement = e.parentElement\n\n            if (\n                parentElement instanceof HTMLElement\n                && this.contentEditableElement\n                && this.contentEditableElement.contains(parentElement)\n            ) {\n                return !!parentElement.closest(selector)\n            }\n        }\n        return false\n    }\n}\n\nclass ContentDocumentHistory {\n    static saveInterval = 1e3;\n    constructor(t=500) {\n        this.maxSize = t\n\n        /**\n         * @type {Array<ContentDocument[\"currentState\"]>}\n         */\n        this.undoStack = []\n\n        /**\n         * @type {Array<ContentDocument[\"currentState\"]>}\n         */\n        this.redoStack = []\n    }\n\n    /**\n     * @param {ContentDocument[\"currentState\"]} t\n     */\n    undo(t) {\n        const e = this.undoStack.pop();\n        if (e) {\n            this.redoStack.push(t)\n            return e\n        }\n        return null\n    }\n\n    /**\n     * @param {ContentDocument[\"currentState\"]} t\n     */\n    redo(t) {\n        const e = this.redoStack.pop();\n        if (e) {\n            this.undoStack.push(t)\n            return e\n        }\n        return null\n    }\n\n    /**\n     * @param {ContentDocument[\"currentState\"]} transaction\n     */\n    add = (transaction) => {\n        this.undoStack.push(transaction)\n        this.redoStack = []\n        this.undoStack.length > this.maxSize && this.undoStack.shift()\n    }\n}\n\n/**\n * @typedef {Object} ContentDocumentOptions\n * @property {string} content - initial string\n * @property {HTMLElement} contentEditableElement - The actual \"contenteditable\" element.\n * @property {string} [eventPrefix=\"content-editor\"]\n */\n\nclass ContentDocument {\n    /**\n     * @param {ContentDocumentOptions} options\n     */\n    constructor(options) {\n        this.content = options.content\n        this.contentEditableElement = options.contentEditableElement\n        this.eventPrefix = options.eventPrefix ?? \"content-editor-\"\n\n        this.selection = new SelectionHelper(this, { eventPrefix: this.eventPrefix })\n        this.history = new ContentDocumentHistory\n\n        this.gutterStart = `<div part=\"gutter\">`\n\n        this.gutterStart = `<div part=\"gutter\" readonly contenteditable=\"false\">`\n        this.gutterEnd = `</div>`\n        this.lineStart = `<div part=\"line\">`\n        this.lineEnd = `</div>`\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     */\n    select(start, end) {\n        this.selection.select({\n            start,\n            end\n        })\n    }\n\n    /**\n     * @param {string} text\n     */\n    insertText(text) {\n        this.replaceText(text, this.currentSelection.start, this.currentSelection.end)\n    }\n\n    /**\n     * @param {string} text\n     * @param {number} start\n     * @param {number} end\n     */\n    replaceText(text, start, end) {\n        const before = this.content.slice(0, start)\n        const after = this.content.slice(end)\n        const newText = `${before}${text}${after}`\n        const selection = {\n            start: before.length + text.length,\n            end: before.length + text.length\n        };\n\n        this.addHistory()\n        this.updateEditor(newText, selection)\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     */\n    insertParagraph(start, end) {\n        this.select(start, end)\n        this.replaceText(\"\\n\" + zeroWidthWhitespace, start, end)\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteText(start, end) {\n        this.replaceText(\"\", Math.max(start, 0), end)\n    }\n\n    deleteCurrentLine() {\n        const {start, end} = this.currentLine;\n        this.deleteText(start, end)\n    }\n\n    undo() {\n        const state = this.history.undo(this.currentState)\n        if (!state) { return }\n\n        const {content, start, end} = state;\n        this.updateEditor(content, {\n            start,\n            end\n        })\n    }\n    redo() {\n        const state = this.history.redo(this.currentState);\n        if (!state) { return }\n\n        const {content, start, end} = state\n        this.updateEditor(content, {\n            start,\n            end\n        })\n    }\n\n    /**\n    * @param {string} str\n    */\n    escapeHTML(str) {\n        return str.replaceAll(/&/g, \"&amp;\")\n        .replaceAll(/</g, \"&lt;\")\n        .replaceAll(/>/g, \"&gt;\")\n        .replaceAll(/\"/g, \"&quot;\")\n        .replaceAll(/'/g, \"&#039;\")\n    }\n\n    render() {\n        const ary = this.content.split(/\\n/)\n        const lines = ary.map((content, index) => {\n            const lineNumber = (index + 1).toString()\n            const gutter = `${this.gutterStart}${lineNumber}${this.gutterEnd}`\n            const line = `${this.lineStart}${content + \"\\n\"}${this.lineEnd}`\n            return `${gutter}${line}`\n        })\n\n        this.contentEditableElement.textContent = \"\"\n        this.contentEditableElement.innerHTML = lines.join(\"\")\n    }\n\n    get isEmpty() {\n        return !this.content?.trim()\n    }\n    get currentSelection() {\n        return this.selection.current()\n    }\n    get currentLine() {\n        return this.selection.currentLine()\n    }\n\n    /**\n     * @param {boolean} bool\n     * @param {string} startText\n     * @param {string} [endText=startText]\n     */\n    toggleSurround(bool, startText, endText=startText) {\n        bool ? this.addSurround(startText, endText) : this.deleteSurround(startText, endText)\n    }\n\n    /**\n     * @param {string} startText\n     * @param {string} [endText=startText]\n     */\n    addSurround(startText, endText=startText) {\n        const { start, end, selection } = this.currentSelection\n        const i = `${startText}${selection}${endText}`;\n        this.replaceText(i, start, end),\n        this.selection.select({\n            start,\n            end: start + selection.length + startText.length + endText.length\n        })\n    }\n\n    /**\n     * @param {string} startText\n     * @param {string} [endText=startText]\n     */\n    deleteSurround(startText, endText=startText) {\n        const {start, end, selection} = this.currentSelection;\n        if (selection.startsWith(startText) && selection.endsWith(endText)) {\n            this.replaceText(\"\", end - endText.length, end)\n            this.replaceText(\"\", start, start + startText.length)\n            this.selection.select({\n                start,\n                end: end - startText.length - endText.length\n            })\n        }\n    }\n\n    /**\n     * @param {string} text\n     */\n    insertAtStart (text) {\n        const {start, end} = this.currentSelection\n        const currentLine = this.currentLine;\n        this.replaceText(text, currentLine.start, currentLine.start)\n        this.selection.select({\n            start: start + text.length,\n            end: end + text.length\n        })\n    }\n\n    /**\n     * @param {string | RegExp} strOrRegexp\n     */\n    deleteFromStart (strOrRegexp) {\n        const {start, end} = this.currentSelection\n        const currentLine = this.currentLine;\n        if (strOrRegexp instanceof RegExp) {\n            const regex = strOrRegexp\n            const e = currentLine.content.match(regex);\n            if (!e) {return};\n            strOrRegexp = e[0]\n        }\n\n        const str = strOrRegexp\n        if (currentLine.content.startsWith(str)) {\n            this.deleteText(currentLine.start, currentLine.start + str.length)\n            this.selection.select({\n                start: start - str.length,\n                end: end - str.length\n            })\n        }\n    }\n    addHistory () {\n        this.history.add(this.currentState)\n    }\n\n    /**\n     * @param {string} text\n     * @param {{ start: number, end: number }} selection\n     */\n    updateEditor (text, selection) {\n        const s = this.content;\n        this.content = text\n        const render = /** @type {any} */ (this.render())\n\n        const changeEvent = new CEChangeEvent(`${this.eventPrefix}change`, {\n            detail: {\n                previousContent: s,\n                newContent: text\n            }\n        })\n\n        const sync = () => {\n            const { start, end } = selection\n\n            this.selection.select({ start, end })\n            this.contentEditableElement.dispatchEvent(changeEvent)\n        }\n\n        if (typeof render === \"object\" && \"then\" in render) {\n            render.then(() => {\n                sync()\n            })\n        } else {\n            sync()\n        }\n\n    }\n    get currentState () {\n        const {start, end} = this.currentSelection;\n        return {\n            content: this.content,\n            start,\n            end\n        }\n    }\n}\nclass HTMLParser {\n    #text;\n\n    /**\n     * @param {string} text\n     */\n    constructor(text) {\n        this.#text = text\n    }\n    asPlainText() {\n        const t = (new window.DOMParser).parseFromString(this.#text, \"text/html\");\n\n        return this.parse(t.body)?.trim()\n    }\n\n    /**\n     * @param {Node} t\n     * @return {string}\n     */\n    parse(t) {\n        return t.nodeType === Node.TEXT_NODE ? (t.nodeValue || \"\") : Array.from(t.childNodes).map(( (e, n) => {\n            const isBlockTag = this.isBlockTag(e)\n            const r = n > 0 && this.isBlockTag(t.childNodes[n - 1]);\n            return (isBlockTag && r ? \"\\n\\n\" : \"\") + this.parse(e)\n        }\n        )).join(\"\")\n    }\n\n    /**\n     * @param {HTMLElement | Node} node\n     */\n    isBlockTag (node) {\n        if (\"tagName\" in node) {\n            return [\"BR\", \"DIV\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"LI\", \"P\", \"TR\"].includes(node.tagName)\n        }\n\n        return false\n    }\n}\n\n/** @typedef {import(\"./content-editor-globals.js\").InputHandlers} InputHandlers */\n\n/**\n * @implements {InputHandlers}\n */\nclass InputHandler {\n    /**\n     * @param {ContentDocument} t\n     */\n    constructor(t) {\n        this.document = t\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {HTMLElement} container\n     */\n    handleInput(evt, container) {\n        evt.preventDefault();\n        const key = `${evt.inputType}`\n\n        if (key in this) {\n            const callback = this[/** @type {keyof this} */ (key)];\n            if (typeof callback === \"function\") {\n                const r = evt.getTargetRanges()[0]\n                const {start, end} = RangeHelper.fromDOMRange(r, container);\n                callback.call(this, evt, start, end)\n            } else {\n                console.error(\"Not handling:\", evt.inputType)\n            }\n        } else {\n            console.error(\"Not handling:\", evt.inputType)\n        }\n\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertText(evt, start, end) {\n        let str;\n        if (evt.data) {\n            str = evt.data;\n        } else if (evt.dataTransfer) {\n            const text = evt.dataTransfer.getData(\"text/html\");\n            str = text ? new HTMLParser(text).asPlainText() : evt.dataTransfer.getData(\"text/plain\")\n        }\n\n        this.document.replaceText(str || \"\", start, end)\n    }\n\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertLineBreak (_evt, start, end) {\n        this.document.insertParagraph(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} _start\n     * @param {number} _end\n     */\n    historyRedo (_evt, _start, _end) {\n        this.document.redo()\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} _start\n     * @param {number} _end\n     */\n    historyUndo (_evt, _start, _end) {\n        this.document.undo()\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertCompositionText(evt, start, end) {\n        this.insertText(evt, start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertParagraph(_evt, start, end) {\n        this.document.insertParagraph(start, end)\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromYank(evt, start, end) {\n        this.insertText(evt, start, end)\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromDrop(evt, start, end) {\n        this.insertText(evt, start, end)\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromPasteAsQuotation(evt, start, end) {\n        const str = evt.dataTransfer?.getData(\"text/plain\") || \"\";\n        this.document.replaceText(`> ${str}`, start, end)\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertTranspose(evt, start, end) {\n        this.insertText(evt, start, end)\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertReplacementText(evt, start, end) {\n        this.insertText(evt, start, end)\n    }\n\n    /**\n     * @param {InputEvent} evt\n     * @param {number} start\n     * @param {number} end\n     */\n    insertFromPaste(evt, start, end) {\n        this.insertText(evt, start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteContentBackward(_evt, start, end) {\n        if (this.document.currentLine.content === \"\\n\" || this.document.currentLine.content === zeroWidthWhitespace) {\n            start -= 1\n        }\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteByCut(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteWordBackward(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteWordForward(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteSoftLineBackward(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteSoftLineForward(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteEntireSoftLine(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteHardLineBackward(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteHardLineForward(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteContent(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n\n    /**\n     * @param {InputEvent} _evt\n     * @param {number} start\n     * @param {number} end\n     */\n    deleteContentForward(_evt, start, end) {\n        this.document.deleteText(start, end)\n    }\n}\n\nclass ActionHandler {\n    /**\n     * @param {ContentDocument} document\n     */\n    constructor(document) {\n        this.document = document\n    }\n\n    /**\n     * @template {Exclude<keyof this & InputEvent[\"inputType\"], \"handleAction\" | \"constructor\">} T\n     * @param {Omit<string, T> | T & {}} t\n     * @param {Event} e\n     */\n    handleAction(t, e) {\n        const handler = this[/** @type {keyof this} */ (t)];\n        typeof handler === \"function\" ? handler.call(this, e) : console.error(\"Not handling:\", t)\n    }\n    undo() {\n        this.document.undo()\n    }\n    redo() {\n        this.document.redo()\n    }\n}\n\nexport default class ContentEditorElement extends LitElement {\n    static formAssociated = true\n\n    /**\n     * @override\n     */\n    static styles = [\n        baseStyles,\n        componentStyles,\n    ]\n\n    constructor() {\n        super()\n        this.internals = this.attachInternals()\n        this.internals.role = \"textbox\"\n\n        this.eventPrefix = \"content-editor-\"\n    }\n\n    /**\n     * @override\n     */\n    connectedCallback() {\n        super.connectedCallback()\n\n        this.updateComplete.then(() => {\n            this.contentEditor = new ContentEditor({\n                eventPrefix: this.eventPrefix,\n                content: this.value || \"\",\n                contentEditableElement: /** @type {HTMLElement} */ (this.contentEditableElement),\n            })\n\n            this.autofocus && this.focus()\n            this.setAttribute(\"initialized\", \"\")\n            this.value = this.contentEditor.content\n        })\n    }\n\n    /**\n     * @override\n     */\n    disconnectedCallback() {\n        this.contentEditor?.destroy()\n        super.disconnectedCallback()\n    }\n\n    /**\n     * @override\n     */\n    render() {\n        return html`<div contenteditable=\"true\" draggable=\"false\" ${ref(/** @type {any} */ (this.contentEditableChanged))}></div>`\n    }\n\n    /**\n     * @param {HTMLElement} contentEditableElement\n     */\n    contentEditableChanged (contentEditableElement) {\n        this.contentEditableElement = contentEditableElement\n    }\n\n    /**\n     * @override\n     * @param {FocusOptions} [options]\n     */\n    focus(options) {\n        const contentEditableElement = this.contentEditableElement\n        if (contentEditableElement) {\n            contentEditableElement.focus(options)\n        }\n    }\n\n    get required() {\n        return this.hasAttribute(\"required\")\n    }\n    set required(t) {\n        t ? this.setAttribute(\"required\", \"\") : this.removeAttribute(\"required\")\n    }\n\n    /**\n     * @override\n     */\n    get autofocus() {\n        return this.hasAttribute(\"autofocus\")\n    }\n\n    /**\n     * @override\n     */\n    set autofocus(t) {\n        t ? this.setAttribute(\"autofocus\", \"\") : this.removeAttribute(\"autofocus\")\n    }\n\n    get value() {\n        return this.contentEditor?.content || \"\"\n    }\n\n    /**\n     * @param {string | undefined | null} val\n     */\n    set value(val) {\n        const editor = this.contentEditor\n        if (editor) {\n            editor.document.content = val || \"\"\n        }\n        this.internals.setFormValue(val || \"\")\n        this.internals.setValidity({})\n        this.render()\n    }\n    get form() {\n        return this.internals.form\n    }\n}\n\n/**\n * @typedef {Object} ContentEditorOptions\n * @property {string} content\n * @property {string} [eventPrefix]\n * @property {HTMLElement} contentEditableElement - The element with `contenteditable=\"true\"`\n */\n\nexport class ContentEditor {\n    /**\n     * @param {ContentEditorOptions} options\n     */\n    constructor ({\n        contentEditableElement,\n        content,\n        eventPrefix,\n    }) {\n        this.eventPrefix = eventPrefix || \"content-editor-\"\n\n        this.document = new ContentDocument({\n            content,\n            contentEditableElement,\n            eventPrefix: this.eventPrefix,\n        })\n        this.inputHandler = new InputHandler(this.document)\n        this.actionHandler = new ActionHandler(this.document)\n        this.keybindings = {\n            \"Ctrl+Z\": \"undo\",\n            \"Ctrl+Shift+Z\": \"redo\"\n        };\n\n        this.render()\n        this.contentEditableElement.addEventListener(\"beforeinput\", this)\n        this.contentEditableElement.addEventListener(\"focusin\", this)\n        this.contentEditableElement.addEventListener(\"keydown\", this)\n        this.contentEditableElement.addEventListener(\"copy\", this)\n        document.addEventListener(\"selectionchange\", this)\n    }\n\n    destroy () {\n        document.removeEventListener(\"selectionchange\", this)\n        this.contentEditableElement.removeEventListener(\"beforeinput\", this)\n        this.contentEditableElement.removeEventListener(\"keydown\", this)\n    }\n\n    /**\n     * @param {CESelectionChangeEvent} _evt\n     */\n    handleChange (_evt) {\n        this.render()\n    }\n\n    /**\n     * @param {Event} evt\n     */\n    handleEvent (evt) {\n         switch (evt.type) {\n            case \"beforeinput\":\n                 this.handleBeforeInput(/** @type {InputEvent} */ (evt))\n                 break;\n             case \"keydown\":\n                 this.handleKeydown(/** @type {KeyboardEvent} */ (evt))\n                 break;\n             case \"selectionchange\":\n                 this.handleSelectionChange(/** @type {Event} */ (evt))\n                 break;\n            case `${this.eventPrefix}change`:\n                 this.handleChange(/** @type {CEChangeEvent} */ (evt))\n                 break;\n             case \"copy\":\n                const selection = document.getSelection();\n                 if (selection) {\n                    evt.preventDefault();\n                    /** @type {ClipboardEvent} */ (evt)?.clipboardData?.setData(\"text/plain\", selection.toString().replaceAll(zeroWidthWhitespace, \"\"));\n                 }\n                 break;\n             case \"focusin\":\n                 // setTimeout(() => {\n                 //     requestAnimationFrame(() => {\n                 //         this.document.selection.updateRange()\n                 //     })\n                 // })\n                 break;\n             default:\n                 console.error(\"Not handling: \", evt.type)\n         }\n    }\n\n    /**\n     * @param {InputEvent} evt\n     */\n    handleBeforeInput (evt) {\n        this.inputHandler.handleInput(evt, this.contentEditableElement)\n    }\n\n    /**\n     * @param {Event} evt\n     */\n    handleSelectionChange (evt) {\n        this.document?.selection.update()\n    }\n\n    /**\n     * @param {KeyboardEvent} evt\n     */\n    handleKeydown (evt) {\n        if (evt.key === \"ArrowUp\") {\n            evt.preventDefault()\n            this.document.selection.moveUp()\n        }\n\n        if (evt.key === \"ArrowDown\") {\n            evt.preventDefault()\n            this.document.selection.moveDown()\n        }\n\n        if (evt.key === \"ArrowRight\") {\n            const {\n                selectedContent\n            } = this.document.selection.lineAt(this.document.selection.end + 1)\n\n            // When its a blank line, handle it slightly differently.\n            if (selectedContent === \"\") {\n                evt.preventDefault()\n                this.document.select(this.document.selection.start + 2, this.document.selection.start + 2)\n            }\n        }\n        if (evt.key === \"ArrowLeft\") {\n            const {\n                selectedContent\n            } = this.document.selection.lineAt(this.document.selection.end - 1)\n\n            // When its a blank line, handle it slightly differently.\n            if (selectedContent === \"\") {\n                const offset = Math.max(0, this.document.selection.start - 2)\n                this.document.select(offset, offset)\n                evt.preventDefault()\n            }\n        }\n        const keyboardEvt = /** @type {KeyboardEvent} */ (evt)\n        const keybinding = this.normalizeKeybinding(keyboardEvt)\n\n        let actionKey = null\n        if (keybinding in this.keybindings) {\n            actionKey = this.keybindings[/** @type {keyof typeof this.keybindings} */ (keybinding)]\n        }\n\n        if (actionKey) {\n            evt.preventDefault()\n            this.actionHandler.handleAction(actionKey, evt)\n        }\n    }\n\n    /**\n     * @param {KeyboardEvent} evt\n     */\n    normalizeKeybinding (evt) {\n        const ary = [];\n        ;(evt.metaKey || evt.ctrlKey) && ary.push(\"Ctrl\")\n\n        evt.altKey && ary.push(\"Alt\")\n        evt.shiftKey && ary.push(\"Shift\")\n        ary.push(evt.key.toUpperCase())\n\n        return ary.join(\"+\")\n    }\n\n    get content () {\n        return this.document.content\n    }\n\n    get contentEditableElement () {\n        return this.document.contentEditableElement\n    }\n\n    render () {\n        return this.document.render()\n    }\n}\ncustomElements.define(\"content-editor\", ContentEditorElement);\n","exports/components/content-editor/content-editor.styles.d.ts":"export const componentStyles: import(\"lit\").CSSResult;\n","exports/components/content-editor/content-editor.styles.js":"import { css } from \"lit\"\n\nexport const componentStyles = css`\n    :host, *, :after, :before {\n      box-sizing: border-box;\n    }\n    :host {\n      display: block;\n    }\n    [contenteditable=\"true\"] {\n      caret-color: black;\n      color: rgb(60, 60, 60);\n      text-align: start;\n      margin: 0;\n      overflow: auto;\n      display: grid;\n      grid-template-columns: max-content 1fr;\n      place-content: start;\n      white-space: pre;\n      word-wrap: normal;\n      min-height: 100%;\n      padding: 0;\n      outline: none;\n      overflow: auto;\n      font-family: monospace;\n      line-height: 1.8;\n      position: relative;\n      overflow-anchor: none;\n      max-block-size:  500px;\n      border: 1px solid #eee;\n    }\n\n    [contenteditable=\"true\"] > [part~=\"gutter\"] {\n      -webkit-user-select: none;\n      user-select: none;\n      text-align: end;\n      display: inline-block;\n      border-right: 1px solid #ddd;\n      background-color: #f5f5f5;\n      padding-inline-end: 4px;\n      padding-inline-start: 6px;\n      min-width: 2ch;\n      color: #888;\n      font-variant-numeric: tabular-nums;\n    }\n\n    /** Fix a bug in firefox around selections. */\n    [contenteditable=\"true\"] > [part~=\"gutter\"]::selection {\n      background: transparent;\n    }\n\n    [contenteditable=\"true\"] > [part~=\"line\"] {\n      min-height: 1lh;\n      min-width: max(max-content, 100%);\n      display: block;\n      padding: 0px 2px 0px 6px;\n      width: max(100%, max-content);\n      background: white;\n    }\n\n    [contenteditable=\"true\"] > [part~=\"active-line\"] {\n      background-color: rgba(200, 240, 255, 1);\n    }\n`\n","exports/index.d.ts":"export { default as ContentEditorElement } from \"./components/content-editor/content-editor-register.js\";\n","exports/index.js":"export { default as ContentEditorElement } from \"./components/content-editor/content-editor-register.js\"\n","exports/styles/base.styles.d.ts":"export const baseStyles: import(\"lit\").CSSResult;\n","exports/styles/base.styles.js":"import { css } from \"lit\";\n\nexport const baseStyles = css`\n  *,\n  *:after,\n  *:before {\n    box-sizing: border-box;\n  }\n\n  :host(:dir(rtl)) *,\n  :host(:dir(rtl)) *:after,\n  :host(:dir(rtl)) *:before {\n    direction: rtl;\n  }\n\n  :host(:dir(ltr)) *,\n  :host(:dir(ltr)) *:after,\n  :host(:dir(ltr)) *:before {\n    direction: ltr;\n  }\n\n  .visually-hidden:not(:focus-within) {\n    position: absolute;\n    overflow: hidden;\n    clip: rect(0 0 0 0);\n    clip-path: inset(50%);\n    width: 1px;\n    height: 1px;\n    white-space: nowrap;\n  }\n\n  [hidden] {\n    display: none !important;\n  }\n\n  :host {\n    display: block;\n  }\n`;\n","internal/base-element.d.ts":"declare const BaseElement_base: {\n    new (...args: any[]): {\n        accessKey: string;\n        readonly accessKeyLabel: string;\n        autocapitalize: string;\n        dir: string;\n        draggable: boolean;\n        hidden: boolean;\n        inert: boolean;\n        innerText: string;\n        lang: string;\n        readonly offsetHeight: number;\n        readonly offsetLeft: number;\n        readonly offsetParent: Element | null;\n        readonly offsetTop: number;\n        readonly offsetWidth: number;\n        outerText: string;\n        popover: string | null;\n        spellcheck: boolean;\n        title: string;\n        translate: boolean;\n        attachInternals(): ElementInternals;\n        click(): void;\n        hidePopover(): void;\n        showPopover(): void;\n        togglePopover(force?: boolean | undefined): boolean;\n        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions | undefined): void;\n        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | undefined): void;\n        removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions | undefined): void;\n        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions | undefined): void;\n        readonly attributes: NamedNodeMap;\n        readonly classList: DOMTokenList;\n        className: string;\n        readonly clientHeight: number;\n        readonly clientLeft: number;\n        readonly clientTop: number;\n        readonly clientWidth: number;\n        id: string;\n        readonly localName: string;\n        readonly namespaceURI: string | null;\n        onfullscreenchange: ((this: Element, ev: Event) => any) | null;\n        onfullscreenerror: ((this: Element, ev: Event) => any) | null;\n        outerHTML: string;\n        readonly ownerDocument: Document;\n        readonly part: DOMTokenList;\n        readonly prefix: string | null;\n        readonly scrollHeight: number;\n        scrollLeft: number;\n        scrollTop: number;\n        readonly scrollWidth: number;\n        readonly shadowRoot: ShadowRoot | null;\n        slot: string;\n        readonly tagName: string;\n        attachShadow(init: ShadowRootInit): ShadowRoot;\n        checkVisibility(options?: CheckVisibilityOptions | undefined): boolean;\n        closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2] | null;\n        closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3] | null;\n        closest<K_4 extends keyof MathMLElementTagNameMap>(selector: K_4): MathMLElementTagNameMap[K_4] | null;\n        closest<E extends Element = Element>(selectors: string): E | null;\n        computedStyleMap(): StylePropertyMapReadOnly;\n        getAttribute(qualifiedName: string): string | null;\n        getAttributeNS(namespace: string | null, localName: string): string | null;\n        getAttributeNames(): string[];\n        getAttributeNode(qualifiedName: string): Attr | null;\n        getAttributeNodeNS(namespace: string | null, localName: string): Attr | null;\n        getBoundingClientRect(): DOMRect;\n        getClientRects(): DOMRectList;\n        getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;\n        getElementsByTagName<K_5 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<HTMLElementTagNameMap[K_5]>;\n        getElementsByTagName<K_6 extends keyof SVGElementTagNameMap>(qualifiedName: K_6): HTMLCollectionOf<SVGElementTagNameMap[K_6]>;\n        getElementsByTagName<K_7 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7): HTMLCollectionOf<MathMLElementTagNameMap[K_7]>;\n        getElementsByTagName<K_8 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8]>;\n        getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;\n        getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/1999/xhtml\", localName: string): HTMLCollectionOf<HTMLElement>;\n        getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/2000/svg\", localName: string): HTMLCollectionOf<SVGElement>;\n        getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/1998/Math/MathML\", localName: string): HTMLCollectionOf<MathMLElement>;\n        getElementsByTagNameNS(namespace: string | null, localName: string): HTMLCollectionOf<Element>;\n        hasAttribute(qualifiedName: string): boolean;\n        hasAttributeNS(namespace: string | null, localName: string): boolean;\n        hasAttributes(): boolean;\n        hasPointerCapture(pointerId: number): boolean;\n        insertAdjacentElement(where: InsertPosition, element: Element): Element | null;\n        insertAdjacentHTML(position: InsertPosition, text: string): void;\n        insertAdjacentText(where: InsertPosition, data: string): void;\n        matches(selectors: string): boolean;\n        releasePointerCapture(pointerId: number): void;\n        removeAttribute(qualifiedName: string): void;\n        removeAttributeNS(namespace: string | null, localName: string): void;\n        removeAttributeNode(attr: Attr): Attr;\n        requestFullscreen(options?: FullscreenOptions | undefined): Promise<void>;\n        requestPointerLock(): void;\n        scroll(options?: ScrollToOptions | undefined): void;\n        scroll(x: number, y: number): void;\n        scrollBy(options?: ScrollToOptions | undefined): void;\n        scrollBy(x: number, y: number): void;\n        scrollIntoView(arg?: boolean | ScrollIntoViewOptions | undefined): void;\n        scrollTo(options?: ScrollToOptions | undefined): void;\n        scrollTo(x: number, y: number): void;\n        setAttribute(qualifiedName: string, value: string): void;\n        setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void;\n        setAttributeNode(attr: Attr): Attr | null;\n        setAttributeNodeNS(attr: Attr): Attr | null;\n        setPointerCapture(pointerId: number): void;\n        toggleAttribute(qualifiedName: string, force?: boolean | undefined): boolean;\n        webkitMatchesSelector(selectors: string): boolean;\n        readonly baseURI: string;\n        readonly childNodes: NodeListOf<ChildNode>;\n        readonly firstChild: ChildNode | null;\n        readonly isConnected: boolean;\n        readonly lastChild: ChildNode | null;\n        readonly nextSibling: ChildNode | null;\n        readonly nodeName: string;\n        readonly nodeType: number;\n        nodeValue: string | null;\n        readonly parentElement: HTMLElement | null;\n        readonly parentNode: ParentNode | null;\n        readonly previousSibling: ChildNode | null;\n        textContent: string | null;\n        appendChild<T_1 extends Node>(node: T_1): T_1;\n        cloneNode(deep?: boolean | undefined): Node;\n        compareDocumentPosition(other: Node): number;\n        contains(other: Node | null): boolean;\n        getRootNode(options?: GetRootNodeOptions | undefined): Node;\n        hasChildNodes(): boolean;\n        insertBefore<T_2 extends Node>(node: T_2, child: Node | null): T_2;\n        isDefaultNamespace(namespace: string | null): boolean;\n        isEqualNode(otherNode: Node | null): boolean;\n        isSameNode(otherNode: Node | null): boolean;\n        lookupNamespaceURI(prefix: string | null): string | null;\n        lookupPrefix(namespace: string | null): string | null;\n        normalize(): void;\n        removeChild<T_3 extends Node>(child: T_3): T_3;\n        replaceChild<T_4 extends Node>(node: Node, child: T_4): T_4;\n        readonly ELEMENT_NODE: 1;\n        readonly ATTRIBUTE_NODE: 2;\n        readonly TEXT_NODE: 3;\n        readonly CDATA_SECTION_NODE: 4;\n        readonly ENTITY_REFERENCE_NODE: 5;\n        readonly ENTITY_NODE: 6;\n        readonly PROCESSING_INSTRUCTION_NODE: 7;\n        readonly COMMENT_NODE: 8;\n        readonly DOCUMENT_NODE: 9;\n        readonly DOCUMENT_TYPE_NODE: 10;\n        readonly DOCUMENT_FRAGMENT_NODE: 11;\n        readonly NOTATION_NODE: 12;\n        readonly DOCUMENT_POSITION_DISCONNECTED: 1;\n        readonly DOCUMENT_POSITION_PRECEDING: 2;\n        readonly DOCUMENT_POSITION_FOLLOWING: 4;\n        readonly DOCUMENT_POSITION_CONTAINS: 8;\n        readonly DOCUMENT_POSITION_CONTAINED_BY: 16;\n        readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;\n        dispatchEvent(event: Event): boolean;\n        ariaAtomic: string | null;\n        ariaAutoComplete: string | null;\n        ariaBusy: string | null;\n        ariaChecked: string | null;\n        ariaColCount: string | null;\n        ariaColIndex: string | null;\n        ariaColSpan: string | null;\n        ariaCurrent: string | null;\n        ariaDescription: string | null;\n        ariaDisabled: string | null;\n        ariaExpanded: string | null;\n        ariaHasPopup: string | null;\n        ariaHidden: string | null;\n        ariaInvalid: string | null;\n        ariaKeyShortcuts: string | null;\n        ariaLabel: string | null;\n        ariaLevel: string | null;\n        ariaLive: string | null;\n        ariaModal: string | null;\n        ariaMultiLine: string | null;\n        ariaMultiSelectable: string | null;\n        ariaOrientation: string | null;\n        ariaPlaceholder: string | null;\n        ariaPosInSet: string | null;\n        ariaPressed: string | null;\n        ariaReadOnly: string | null;\n        ariaRequired: string | null;\n        ariaRoleDescription: string | null;\n        ariaRowCount: string | null;\n        ariaRowIndex: string | null;\n        ariaRowSpan: string | null;\n        ariaSelected: string | null;\n        ariaSetSize: string | null;\n        ariaSort: string | null;\n        ariaValueMax: string | null;\n        ariaValueMin: string | null;\n        ariaValueNow: string | null;\n        ariaValueText: string | null;\n        role: string | null;\n        animate(keyframes: PropertyIndexedKeyframes | Keyframe[] | null, options?: number | KeyframeAnimationOptions | undefined): Animation;\n        getAnimations(options?: GetAnimationsOptions | undefined): Animation[];\n        after(...nodes: (string | Node)[]): void;\n        before(...nodes: (string | Node)[]): void;\n        remove(): void;\n        replaceWith(...nodes: (string | Node)[]): void;\n        innerHTML: string;\n        readonly nextElementSibling: Element | null;\n        readonly previousElementSibling: Element | null;\n        readonly childElementCount: number;\n        readonly children: HTMLCollection;\n        readonly firstElementChild: Element | null;\n        readonly lastElementChild: Element | null;\n        append(...nodes: (string | Node)[]): void;\n        prepend(...nodes: (string | Node)[]): void;\n        querySelector<K_9 extends keyof HTMLElementTagNameMap>(selectors: K_9): HTMLElementTagNameMap[K_9] | null;\n        querySelector<K_10 extends keyof SVGElementTagNameMap>(selectors: K_10): SVGElementTagNameMap[K_10] | null;\n        querySelector<K_11 extends keyof MathMLElementTagNameMap>(selectors: K_11): MathMLElementTagNameMap[K_11] | null;\n        querySelector<K_12 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12): HTMLElementDeprecatedTagNameMap[K_12] | null;\n        querySelector<E_1 extends Element = Element>(selectors: string): E_1 | null;\n        querySelectorAll<K_13 extends keyof HTMLElementTagNameMap>(selectors: K_13): NodeListOf<HTMLElementTagNameMap[K_13]>;\n        querySelectorAll<K_14 extends keyof SVGElementTagNameMap>(selectors: K_14): NodeListOf<SVGElementTagNameMap[K_14]>;\n        querySelectorAll<K_15 extends keyof MathMLElementTagNameMap>(selectors: K_15): NodeListOf<MathMLElementTagNameMap[K_15]>;\n        querySelectorAll<K_16 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16]>;\n        querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;\n        replaceChildren(...nodes: (string | Node)[]): void;\n        readonly assignedSlot: HTMLSlotElement | null;\n        readonly attributeStyleMap: StylePropertyMap;\n        readonly style: CSSStyleDeclaration;\n        contentEditable: string;\n        enterKeyHint: string;\n        inputMode: string;\n        readonly isContentEditable: boolean;\n        onabort: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n        onanimationcancel: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onanimationend: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onanimationiteration: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onanimationstart: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onauxclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onbeforeinput: ((this: GlobalEventHandlers, ev: InputEvent) => any) | null;\n        onbeforetoggle: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onblur: ((this: GlobalEventHandlers, ev: FocusEvent) => any) | null;\n        oncancel: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncanplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncanplaythrough: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onclose: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncontextmenu: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        oncopy: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) | null;\n        oncuechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncut: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) | null;\n        ondblclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        ondrag: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragend: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragenter: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragleave: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragover: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragstart: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondrop: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondurationchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onemptied: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onended: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onerror: OnErrorEventHandler;\n        onfocus: ((this: GlobalEventHandlers, ev: FocusEvent) => any) | null;\n        onformdata: ((this: GlobalEventHandlers, ev: FormDataEvent) => any) | null;\n        ongotpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        oninput: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oninvalid: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onkeydown: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n        onkeypress: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n        onkeyup: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n        onload: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onloadeddata: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onloadedmetadata: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onloadstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onlostpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseenter: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseleave: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmousemove: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseout: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseover: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseup: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onpaste: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) | null;\n        onpause: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onplaying: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onpointercancel: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerdown: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerenter: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerleave: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointermove: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerout: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerover: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerup: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onprogress: ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) | null;\n        onratechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onreset: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onresize: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n        onscroll: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onscrollend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onsecuritypolicyviolation: ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) | null;\n        onseeked: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onseeking: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onselect: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onselectionchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onselectstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onslotchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onstalled: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onsubmit: ((this: GlobalEventHandlers, ev: SubmitEvent) => any) | null;\n        onsuspend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        ontimeupdate: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        ontoggle: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        ontouchcancel?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontouchend?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontouchmove?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontouchstart?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontransitioncancel: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        ontransitionend: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        ontransitionrun: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        ontransitionstart: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        onvolumechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwaiting: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkitanimationend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkitanimationiteration: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkitanimationstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkittransitionend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwheel: ((this: GlobalEventHandlers, ev: WheelEvent) => any) | null;\n        autofocus: boolean;\n        readonly dataset: DOMStringMap;\n        nonce?: string | undefined;\n        tabIndex: number;\n        blur(): void;\n        focus(options?: FocusOptions | undefined): void;\n    };\n    defineProperties<T_5 extends import(\"konnors-lit-helpers/exports/properties.js\").GenericConstructable<HTMLElement> & import(\"konnors-lit-helpers/exports/properties.js\").LitLike, U extends Record<string, import(\"konnors-lit-helpers/exports/properties.js\").LitProperty>>(this: T_5, options: U): {\n        new (...args: any[]): InstanceType<T_5> & import(\"konnors-lit-helpers/exports/properties.js\").PropertiesMixin<U>;\n        prototype: InstanceType<T_5>;\n        properties: T_5[\"properties\"] & U;\n    } & T_5;\n    properties: typeof import(\"lit\").LitElement[\"properties\"];\n} & {\n    new (...args: any[]): {\n        accessKey: string;\n        readonly accessKeyLabel: string;\n        autocapitalize: string;\n        dir: string;\n        draggable: boolean;\n        hidden: boolean;\n        inert: boolean;\n        innerText: string;\n        lang: string;\n        readonly offsetHeight: number;\n        readonly offsetLeft: number;\n        readonly offsetParent: Element | null;\n        readonly offsetTop: number;\n        readonly offsetWidth: number;\n        outerText: string;\n        spellcheck: boolean;\n        title: string;\n        translate: boolean;\n        attachInternals(): ElementInternals;\n        click(): void;\n        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions | undefined): void;\n        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | undefined): void;\n        removeEventListener<K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | EventListenerOptions | undefined): void;\n        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions | undefined): void;\n        readonly attributes: NamedNodeMap;\n        readonly classList: DOMTokenList;\n        className: string;\n        readonly clientHeight: number;\n        readonly clientLeft: number;\n        readonly clientTop: number;\n        readonly clientWidth: number;\n        id: string;\n        readonly localName: string;\n        readonly namespaceURI: string | null;\n        onfullscreenchange: ((this: Element, ev: Event) => any) | null;\n        onfullscreenerror: ((this: Element, ev: Event) => any) | null;\n        outerHTML: string;\n        readonly ownerDocument: Document;\n        readonly part: DOMTokenList;\n        readonly prefix: string | null;\n        readonly scrollHeight: number;\n        scrollLeft: number;\n        scrollTop: number;\n        readonly scrollWidth: number;\n        readonly shadowRoot: ShadowRoot | null;\n        slot: string;\n        readonly tagName: string;\n        attachShadow(init: ShadowRootInit): ShadowRoot;\n        checkVisibility(options?: CheckVisibilityOptions | undefined): boolean;\n        closest<K_2 extends keyof HTMLElementTagNameMap>(selector: K_2): HTMLElementTagNameMap[K_2] | null;\n        closest<K_3 extends keyof SVGElementTagNameMap>(selector: K_3): SVGElementTagNameMap[K_3] | null;\n        closest<K_4 extends keyof MathMLElementTagNameMap>(selector: K_4): MathMLElementTagNameMap[K_4] | null;\n        closest<E extends Element = Element>(selectors: string): E | null;\n        getAttribute(qualifiedName: string): string | null;\n        getAttributeNS(namespace: string | null, localName: string): string | null;\n        getAttributeNames(): string[];\n        getAttributeNode(qualifiedName: string): Attr | null;\n        getAttributeNodeNS(namespace: string | null, localName: string): Attr | null;\n        getBoundingClientRect(): DOMRect;\n        getClientRects(): DOMRectList;\n        getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;\n        getElementsByTagName<K_5 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5): HTMLCollectionOf<HTMLElementTagNameMap[K_5]>;\n        getElementsByTagName<K_6 extends keyof SVGElementTagNameMap>(qualifiedName: K_6): HTMLCollectionOf<SVGElementTagNameMap[K_6]>;\n        getElementsByTagName<K_7 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7): HTMLCollectionOf<MathMLElementTagNameMap[K_7]>;\n        getElementsByTagName<K_8 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8]>;\n        getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;\n        getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/1999/xhtml\", localName: string): HTMLCollectionOf<HTMLElement>;\n        getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/2000/svg\", localName: string): HTMLCollectionOf<SVGElement>;\n        getElementsByTagNameNS(namespaceURI: \"http://www.w3.org/1998/Math/MathML\", localName: string): HTMLCollectionOf<MathMLElement>;\n        getElementsByTagNameNS(namespace: string | null, localName: string): HTMLCollectionOf<Element>;\n        hasAttribute(qualifiedName: string): boolean;\n        hasAttributeNS(namespace: string | null, localName: string): boolean;\n        hasAttributes(): boolean;\n        hasPointerCapture(pointerId: number): boolean;\n        insertAdjacentElement(where: InsertPosition, element: Element): Element | null;\n        insertAdjacentHTML(position: InsertPosition, text: string): void;\n        insertAdjacentText(where: InsertPosition, data: string): void;\n        matches(selectors: string): boolean;\n        releasePointerCapture(pointerId: number): void;\n        removeAttribute(qualifiedName: string): void;\n        removeAttributeNS(namespace: string | null, localName: string): void;\n        removeAttributeNode(attr: Attr): Attr;\n        requestFullscreen(options?: FullscreenOptions | undefined): Promise<void>;\n        requestPointerLock(): void;\n        scroll(options?: ScrollToOptions | undefined): void;\n        scroll(x: number, y: number): void;\n        scrollBy(options?: ScrollToOptions | undefined): void;\n        scrollBy(x: number, y: number): void;\n        scrollIntoView(arg?: boolean | ScrollIntoViewOptions | undefined): void;\n        scrollTo(options?: ScrollToOptions | undefined): void;\n        scrollTo(x: number, y: number): void;\n        setAttribute(qualifiedName: string, value: string): void;\n        setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void;\n        setAttributeNode(attr: Attr): Attr | null;\n        setAttributeNodeNS(attr: Attr): Attr | null;\n        setPointerCapture(pointerId: number): void;\n        toggleAttribute(qualifiedName: string, force?: boolean | undefined): boolean;\n        webkitMatchesSelector(selectors: string): boolean;\n        readonly baseURI: string;\n        readonly childNodes: NodeListOf<ChildNode>;\n        readonly firstChild: ChildNode | null;\n        readonly isConnected: boolean;\n        readonly lastChild: ChildNode | null;\n        readonly nextSibling: ChildNode | null;\n        readonly nodeName: string;\n        readonly nodeType: number;\n        nodeValue: string | null;\n        readonly parentElement: HTMLElement | null;\n        readonly parentNode: ParentNode | null;\n        readonly previousSibling: ChildNode | null;\n        textContent: string | null;\n        appendChild<T_1 extends Node>(node: T_1): T_1;\n        cloneNode(deep?: boolean | undefined): Node;\n        compareDocumentPosition(other: Node): number;\n        contains(other: Node | null): boolean;\n        getRootNode(options?: GetRootNodeOptions | undefined): Node;\n        hasChildNodes(): boolean;\n        insertBefore<T_2 extends Node>(node: T_2, child: Node | null): T_2;\n        isDefaultNamespace(namespace: string | null): boolean;\n        isEqualNode(otherNode: Node | null): boolean;\n        isSameNode(otherNode: Node | null): boolean;\n        lookupNamespaceURI(prefix: string | null): string | null;\n        lookupPrefix(namespace: string | null): string | null;\n        normalize(): void;\n        removeChild<T_3 extends Node>(child: T_3): T_3;\n        replaceChild<T_4 extends Node>(node: Node, child: T_4): T_4;\n        readonly ELEMENT_NODE: 1;\n        readonly ATTRIBUTE_NODE: 2;\n        readonly TEXT_NODE: 3;\n        readonly CDATA_SECTION_NODE: 4;\n        readonly ENTITY_REFERENCE_NODE: 5;\n        readonly ENTITY_NODE: 6;\n        readonly PROCESSING_INSTRUCTION_NODE: 7;\n        readonly COMMENT_NODE: 8;\n        readonly DOCUMENT_NODE: 9;\n        readonly DOCUMENT_TYPE_NODE: 10;\n        readonly DOCUMENT_FRAGMENT_NODE: 11;\n        readonly NOTATION_NODE: 12;\n        readonly DOCUMENT_POSITION_DISCONNECTED: 1;\n        readonly DOCUMENT_POSITION_PRECEDING: 2;\n        readonly DOCUMENT_POSITION_FOLLOWING: 4;\n        readonly DOCUMENT_POSITION_CONTAINS: 8;\n        readonly DOCUMENT_POSITION_CONTAINED_BY: 16;\n        readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;\n        dispatchEvent(event: Event): boolean;\n        ariaAtomic: string | null;\n        ariaAutoComplete: string | null;\n        ariaBusy: string | null;\n        ariaChecked: string | null;\n        ariaColCount: string | null;\n        ariaColIndex: string | null;\n        ariaColSpan: string | null;\n        ariaCurrent: string | null;\n        ariaDisabled: string | null;\n        ariaExpanded: string | null;\n        ariaHasPopup: string | null;\n        ariaHidden: string | null;\n        ariaInvalid: string | null;\n        ariaKeyShortcuts: string | null;\n        ariaLabel: string | null;\n        ariaLevel: string | null;\n        ariaLive: string | null;\n        ariaModal: string | null;\n        ariaMultiLine: string | null;\n        ariaMultiSelectable: string | null;\n        ariaOrientation: string | null;\n        ariaPlaceholder: string | null;\n        ariaPosInSet: string | null;\n        ariaPressed: string | null;\n        ariaReadOnly: string | null;\n        ariaRequired: string | null;\n        ariaRoleDescription: string | null;\n        ariaRowCount: string | null;\n        ariaRowIndex: string | null;\n        ariaRowSpan: string | null;\n        ariaSelected: string | null;\n        ariaSetSize: string | null;\n        ariaSort: string | null;\n        ariaValueMax: string | null;\n        ariaValueMin: string | null;\n        ariaValueNow: string | null;\n        ariaValueText: string | null;\n        role: string | null;\n        animate(keyframes: PropertyIndexedKeyframes | Keyframe[] | null, options?: number | KeyframeAnimationOptions | undefined): Animation;\n        getAnimations(options?: GetAnimationsOptions | undefined): Animation[];\n        after(...nodes: (string | Node)[]): void;\n        before(...nodes: (string | Node)[]): void;\n        remove(): void;\n        replaceWith(...nodes: (string | Node)[]): void;\n        innerHTML: string;\n        readonly nextElementSibling: Element | null;\n        readonly previousElementSibling: Element | null;\n        readonly childElementCount: number;\n        readonly children: HTMLCollection;\n        readonly firstElementChild: Element | null;\n        readonly lastElementChild: Element | null;\n        append(...nodes: (string | Node)[]): void;\n        prepend(...nodes: (string | Node)[]): void;\n        querySelector<K_9 extends keyof HTMLElementTagNameMap>(selectors: K_9): HTMLElementTagNameMap[K_9] | null;\n        querySelector<K_10 extends keyof SVGElementTagNameMap>(selectors: K_10): SVGElementTagNameMap[K_10] | null;\n        querySelector<K_11 extends keyof MathMLElementTagNameMap>(selectors: K_11): MathMLElementTagNameMap[K_11] | null;\n        querySelector<K_12 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12): HTMLElementDeprecatedTagNameMap[K_12] | null;\n        querySelector<E_1 extends Element = Element>(selectors: string): E_1 | null;\n        querySelectorAll<K_13 extends keyof HTMLElementTagNameMap>(selectors: K_13): NodeListOf<HTMLElementTagNameMap[K_13]>;\n        querySelectorAll<K_14 extends keyof SVGElementTagNameMap>(selectors: K_14): NodeListOf<SVGElementTagNameMap[K_14]>;\n        querySelectorAll<K_15 extends keyof MathMLElementTagNameMap>(selectors: K_15): NodeListOf<MathMLElementTagNameMap[K_15]>;\n        querySelectorAll<K_16 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16]>;\n        querySelectorAll<E_2 extends Element = Element>(selectors: string): NodeListOf<E_2>;\n        replaceChildren(...nodes: (string | Node)[]): void;\n        readonly assignedSlot: HTMLSlotElement | null;\n        readonly style: CSSStyleDeclaration;\n        contentEditable: string;\n        enterKeyHint: string;\n        inputMode: string;\n        readonly isContentEditable: boolean;\n        onabort: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n        onanimationcancel: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onanimationend: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onanimationiteration: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onanimationstart: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n        onauxclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onbeforeinput: ((this: GlobalEventHandlers, ev: InputEvent) => any) | null;\n        onblur: ((this: GlobalEventHandlers, ev: FocusEvent) => any) | null;\n        oncancel: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncanplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncanplaythrough: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onclose: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncontextmenu: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        oncopy: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) | null;\n        oncuechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oncut: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) | null;\n        ondblclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        ondrag: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragend: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragenter: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragleave: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragover: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondragstart: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondrop: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n        ondurationchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onemptied: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onended: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onerror: OnErrorEventHandler;\n        onfocus: ((this: GlobalEventHandlers, ev: FocusEvent) => any) | null;\n        onformdata: ((this: GlobalEventHandlers, ev: FormDataEvent) => any) | null;\n        ongotpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        oninput: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        oninvalid: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onkeydown: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n        onkeypress: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n        onkeyup: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n        onload: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onloadeddata: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onloadedmetadata: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onloadstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onlostpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseenter: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseleave: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmousemove: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseout: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseover: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onmouseup: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n        onpaste: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) | null;\n        onpause: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onplaying: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onpointercancel: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerdown: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerenter: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerleave: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointermove: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerout: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerover: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onpointerup: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n        onprogress: ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) | null;\n        onratechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onreset: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onresize: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n        onscroll: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onsecuritypolicyviolation: ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) | null;\n        onseeked: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onseeking: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onselect: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onselectionchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onselectstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onslotchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onstalled: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onsubmit: ((this: GlobalEventHandlers, ev: SubmitEvent) => any) | null;\n        onsuspend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        ontimeupdate: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        ontoggle: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        ontouchcancel?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontouchend?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontouchmove?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontouchstart?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null | undefined;\n        ontransitioncancel: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        ontransitionend: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        ontransitionrun: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        ontransitionstart: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n        onvolumechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwaiting: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkitanimationend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkitanimationiteration: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkitanimationstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwebkittransitionend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n        onwheel: ((this: GlobalEventHandlers, ev: WheelEvent) => any) | null;\n        autofocus: boolean;\n        readonly dataset: DOMStringMap;\n        nonce?: string | undefined;\n        tabIndex: number;\n        blur(): void;\n        focus(options?: FocusOptions | undefined): void;\n    };\n    baseName: string;\n    warnOnExistingElement: boolean;\n    define(name?: null | undefined | string, ctor?: null | undefined | CustomElementConstructor, options?: ElementDefinitionOptions | undefined): void;\n} & typeof LitElement;\n/**\n * @customElement\n */\nexport class BaseElement extends BaseElement_base {\n    /**\n     * @type {Record<string, typeof HTMLElement & { define?: (...args: any[]) => void }>}\n     */\n    static dependencies: Record<string, typeof HTMLElement & {\n        define?: (...args: any[]) => void;\n    }>;\n    static version: string;\n    /**\n     * Gets directionality of the element\n     * @returns {\"ltr\" | \"rtl\"}\n     */\n    getTextDirection(): \"ltr\" | \"rtl\";\n}\nimport { LitElement } from \"lit\";\nexport {};\n","internal/base-element.js":"import { LitElement } from \"lit\";\nimport { DefineableMixin } from \"web-component-define\";\nimport { version } from \"./version.js\";\nimport { defineablePropertiesMixin } from \"konnors-lit-helpers/exports/properties.js\";\n\n/**\n * @customElement\n */\nexport class BaseElement extends defineablePropertiesMixin(DefineableMixin(LitElement)) {\n  /**\n   * @type {Record<string, typeof HTMLElement & { define?: (...args: any[]) => void }>}\n   */\n  static dependencies = {};\n\n  static version = version;\n\n  constructor() {\n    super();\n    Object.entries(\n      /** @type {typeof BaseElement} */ (this.constructor).dependencies,\n    ).forEach(([name, ctor]) => {\n      if (typeof ctor.define === \"function\") {\n        ctor.define(name);\n      } else {\n        if (!customElements.get(name)) {\n          customElements.define(name, ctor)\n        }\n      }\n    });\n  }\n\n  /**\n   * Gets directionality of the element\n   * @returns {\"ltr\" | \"rtl\"}\n   */\n  getTextDirection() {\n    return this.matches(\":dir(rtl)\") ? \"rtl\" : \"ltr\";\n  }\n}\n","internal/base-event.d.ts":"export class BaseEvent extends Event {\n}\n","internal/base-event.js":"export class BaseEvent extends Event {\n  /**\n   * @param {string} name\n   * @param {EventInit} [options={}]\n   */\n  constructor(name, options = {}) {\n    if (options.bubbles == null) options.bubbles = true;\n    if (options.composed == null) options.composed = true;\n    super(name, options);\n  }\n}\n","internal/version.d.ts":"export const version: \"0.0.0\";\n","internal/version.js":"// This file is auto-generated. Do not manually edit this.\nexport const version = \"0.0.0\";"}
